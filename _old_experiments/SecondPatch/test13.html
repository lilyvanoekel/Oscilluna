<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Subtle Bubbles with Eraser Mode</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div class="noise"></div>

    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.module.js';
        import { gsap } from 'https://cdn.jsdelivr.net/npm/gsap@3.11.0/index.js';

        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(
            window.innerWidth / -2,
            window.innerWidth / 2,
            window.innerHeight / 2,
            window.innerHeight / -2,
            1,
            1000
        );
        const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.querySelector('.noise').appendChild(renderer.domElement);

        camera.position.z = 5;

        let isPainting = false;
        let isErasing = false;
        const brushRadius = 50;
        const paintedAreas = [];
        const bubbles = []; // Track bubbles for erasing

        const createCircle = (x, y) => {
            const size = gsap.utils.random(5, 15);
            const color = new THREE.Color(`hsl(${gsap.utils.random(0, 360)}, 80%, 70%)`);

            const geometry = new THREE.CircleGeometry(size, 32);
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0 // Start fully transparent
            });
            const mesh = new THREE.Mesh(geometry, material);

            mesh.position.set(x, y, 0);
            scene.add(mesh);
            bubbles.push(mesh); // Track bubbles for eraser

            // Fade in
            gsap.to(mesh.material, {
                opacity: gsap.utils.random(0.5, 1),
                duration: gsap.utils.random(1, 2),
                ease: 'sine.inOut',
                onComplete: () => {
                    // Fade out after fading in
                    gsap.to(mesh.material, {
                        opacity: 0,
                        duration: gsap.utils.random(2, 4),
                        ease: 'sine.inOut',
                        onComplete: () => {
                            scene.remove(mesh);
                            mesh.geometry.dispose();
                            mesh.material.dispose();

                            // Remove the bubble from the tracking array
                            const index = bubbles.indexOf(mesh);
                            if (index !== -1) bubbles.splice(index, 1);
                        }
                    });
                }
            });

            gsap.to(mesh.position, {
                x: x + gsap.utils.random(-20, 20),
                y: y + gsap.utils.random(-20, 20),
                duration: gsap.utils.random(2, 4),
                ease: 'sine.inOut',
            });
        };

        const createPaintArea = (x, y) => {
            if (paintedAreas.some(area => Math.hypot(area.x - x, area.y - y) < brushRadius)) {
                return; // Area is already painted, don't add more bubbles here
            }

            paintedAreas.push({ x, y });
            spawnBubblesInArea(x, y);
        };

        const eraseBubbles = (x, y) => {
            for (let i = bubbles.length - 1; i >= 0; i--) {
                const bubble = bubbles[i];
                if (Math.hypot(bubble.position.x - x, bubble.position.y - y) < brushRadius) {
                    gsap.to(bubble.material, {
                        opacity: 0,
                        duration: 0.5,
                        ease: 'sine.inOut',
                        onComplete: () => {
                            scene.remove(bubble);
                            bubble.geometry.dispose();
                            bubble.material.dispose();
                            bubbles.splice(i, 1); // Remove from the array
                        }
                    });
                }
            }
        };

        const onPointerMove = (event) => {
            const rect = renderer.domElement.getBoundingClientRect();
            const mouseX = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            const mouseY = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            const x = mouseX * (window.innerWidth / 2);
            const y = mouseY * (window.innerHeight / 2);

            if (isPainting) {
                createPaintArea(x, y);
            } else if (isErasing) {
                eraseBubbles(x, y);
            }
        };

        const onPointerDown = (event) => {
            if (event.button === 2) { // Right click
                isErasing = true;
            } else {
                isPainting = true;
            }
        };

        const onPointerUp = () => {
            isPainting = false;
            isErasing = false;
        };

        window.addEventListener('pointermove', onPointerMove);
        window.addEventListener('pointerdown', onPointerDown);
        window.addEventListener('pointerup', onPointerUp);

        // Disable context menu on right click
        window.addEventListener('contextmenu', event => event.preventDefault());

        const animate = () => {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        };

        const spawnBubblesInArea = (x, y) => {
            const spawnBubble = () => {
                const offsetX = gsap.utils.random(-brushRadius, brushRadius);
                const offsetY = gsap.utils.random(-brushRadius, brushRadius);
                createCircle(x + offsetX, y + offsetY);

                setTimeout(spawnBubble, gsap.utils.random(300, 1000));
            };

            spawnBubble();
        };

        animate();
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Continuous Simple Shapes</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div class="noise"></div>

    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.module.js';
        import { gsap } from 'https://cdn.jsdelivr.net/npm/gsap@3.11.0/index.js';

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.querySelector('.noise').appendChild(renderer.domElement);

        camera.position.z = 500;

        const vertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const fragmentShader = `
            varying vec2 vUv;
            uniform vec3 color;
            uniform float opacity;

            void main() {
                float dist = distance(vUv, vec2(0.5, 0.5));
                float alpha = 1.0 - smoothstep(0.45, 0.5, dist);

                gl_FragColor = vec4(color, alpha * opacity);

                // Glow effect
                float glow = smoothstep(0.3, 0.5, dist);
                gl_FragColor.rgb += gl_FragColor.rgb * glow * 1.2;
            }
        `;

        const addShape = (x, y) => {
            const size = gsap.utils.random(5, 10); // Smaller shapes
            const color = new THREE.Color(`hsl(${gsap.utils.random(0, 360)}, 80%, 70%)`); // Bright colors

            const geometry = new THREE.CircleGeometry(size, 32); // Simple circle shape
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    color: { value: color },
                    opacity: { value: 0.8 }
                },
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                transparent: true
            });
            const mesh = new THREE.Mesh(geometry, material);

            mesh.position.x = x !== undefined ? x : gsap.utils.random(-window.innerWidth / 2, window.innerWidth / 2);
            mesh.position.y = y !== undefined ? y : gsap.utils.random(-window.innerHeight / 2, window.innerHeight / 2);

            scene.add(mesh);

            gsap.to(material.uniforms.opacity, {
                value: 0,
                duration: gsap.utils.random(0.7, 2),
                onComplete: () => {
                    scene.remove(mesh);
                    mesh.geometry.dispose();
                    mesh.material.dispose();
                }
            });

            gsap.to(mesh.position, {
                x: mesh.position.x + gsap.utils.random(-100, 100), // Spread out more
                y: mesh.position.y + gsap.utils.random(-100, 100),
                duration: gsap.utils.random(1, 3),
                ease: 'power1.inOut',
            });
        };

        setInterval(() => addShape(), 100); // Continuous animation

        window.addEventListener('mousemove', (event) => {
            const mouseX = event.clientX - window.innerWidth / 2;
            const mouseY = window.innerHeight / 2 - event.clientY;

            for (let i = 0; i < 2; i++) {
                const offsetX = gsap.utils.random(-100, 100);
                const offsetY = gsap.utils.random(-100, 100);
                setTimeout(
                    () => {
                        addShape(mouseX + offsetX, mouseY + offsetY);
                    },
                    gsap.utils.random(0, 400)
                );
            }
        });

        const animate = () => {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        };
        animate();
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Masked Shader Visualization</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
        }
		#maskCanvas {
			opacity: 0;
			position: absolute;
			left: 0;
			top: 0;
			width: 100%;
			height: 100%;
		}
    </style>
</head>
<body>
    <canvas id="maskCanvas"></canvas>
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.module.js';

        const width = window.innerWidth;
        const height = window.innerHeight;

        // Create the canvas for the 1-bit mask
        const maskCanvas = document.getElementById('maskCanvas');
        maskCanvas.width = width;
        maskCanvas.height = height;
        const maskCtx = maskCanvas.getContext('2d');

        // Set up Three.js scene
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(width / -2, width / 2, height / 2, height / -2, 1, 1000);
        const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setSize(width, height);
        document.body.appendChild(renderer.domElement);

        camera.position.z = 5;

        // Initialize the mask with black (0)
        maskCtx.fillStyle = "black";
        maskCtx.fillRect(0, 0, width, height);

        // Brush properties
        const brushRadius = 50;
        let isDrawing = false;
        let isErasing = false;

        const drawBrushStroke = (x, y, isErasing) => {
            maskCtx.fillStyle = isErasing ? "black" : "white"; // Erase with black, draw with white
            maskCtx.beginPath();
            maskCtx.arc(x, y, brushRadius, 0, Math.PI * 2);
            maskCtx.fill();
            updateTexture(); // Update texture after drawing
        };

        maskCanvas.addEventListener('pointerdown', (event) => {
            if (event.button === 2) { // Right-click
                isErasing = true;
            } else {
                isDrawing = true;
            }
        });

        maskCanvas.addEventListener('pointerup', () => {
            isDrawing = false;
            isErasing = false;
        });

        maskCanvas.addEventListener('pointermove', (event) => {
            if (isDrawing || isErasing) {
                const rect = maskCanvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                drawBrushStroke(x, y, isErasing);
            }
        });

        // Disable the context menu on right-click
        maskCanvas.addEventListener('contextmenu', (event) => event.preventDefault());

        // Create a texture from the mask canvas
        const maskTexture = new THREE.Texture(maskCanvas);
        maskTexture.minFilter = THREE.NearestFilter;
        maskTexture.magFilter = THREE.NearestFilter;
        maskTexture.generateMipmaps = false;

        // Shader material that visualizes the mask
        const material = new THREE.ShaderMaterial({
    uniforms: {
        maskTexture: { value: maskTexture },
        iTime: { value: 0 },
        iResolution: { value: new THREE.Vector2(width, height) }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        #define TAU 6.28318530718
        #define TILING_FACTOR 1.0
        #define MAX_ITER 8

        uniform sampler2D maskTexture;
        uniform float iTime;
        uniform vec2 iResolution;
        varying vec2 vUv;

        float waterHighlight(vec2 p, float time, float foaminess)
        {
            vec2 i = vec2(p);
            float c = 0.0;
            float foaminess_factor = mix(1.0, 6.0, foaminess);
            float inten = .005 * foaminess_factor;

            for (int n = 0; n < MAX_ITER; n++) 
            {
                float t = time * (1.0 - (3.5 / float(n+1)));
                i = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));
                c += 1.0/length(vec2(p.x / (sin(i.x+t)),p.y / (cos(i.y+t))));
            }
            c = 0.2 + c / (inten * float(MAX_ITER));
            c = 1.17-pow(c, 1.4);
            c = pow(abs(c), 8.0);
            return c / sqrt(foaminess_factor);
        }

        void mainImage( out vec4 fragColor, in vec2 fragCoord ) 
        {
            float time = iTime * 0.1+23.0;
            vec2 uv = fragCoord.xy / iResolution.xy;
            vec2 uv_square = vec2(uv.x * iResolution.x / iResolution.y, uv.y);
            float dist_center = pow(2.0*length(uv - 0.5), 2.0);
            
            float foaminess = smoothstep(0.4, 1.8, dist_center);
            float clearness = 0.1 + 0.9*smoothstep(0.1, 0.5, dist_center);
            
            vec2 p = mod(uv_square*TAU*TILING_FACTOR, TAU)-250.0;
            
            float c = waterHighlight(p, time, foaminess);
            
            vec3 water_color = vec3(0.0, 0.35, 0.5);
            vec3 color = vec3(c);
            color = clamp(color + water_color, 0.0, 1.0);
            
            color = mix(water_color, color, clearness);

            fragColor = vec4(color, 1.0);
        }

        void main() {
            vec2 uv = vUv;

            // Sample the mask and its neighboring pixels to create a blurred effect
            float maskValue = texture2D(maskTexture, uv).r;
            float blurAmount = 0.005; // Adjust for more or less blur
            float blurredMask = smoothstep(0.2, 0.8, maskValue);

            // Add surrounding pixels to the blur
            blurredMask += smoothstep(0.2, 0.8, texture2D(maskTexture, uv + vec2(blurAmount, 0.0)).r);
            blurredMask += smoothstep(0.2, 0.8, texture2D(maskTexture, uv - vec2(blurAmount, 0.0)).r);
            blurredMask += smoothstep(0.2, 0.8, texture2D(maskTexture, uv + vec2(0.0, blurAmount)).r);
            blurredMask += smoothstep(0.2, 0.8, texture2D(maskTexture, uv - vec2(0.0, blurAmount)).r);

            blurredMask /= 5.0; // Average the surrounding pixels

            if (blurredMask > 0.1) {
                mainImage(gl_FragColor, uv * iResolution.xy);
                gl_FragColor.rgb *= blurredMask; // Apply the mask
            } else {
                gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0); // Black where the mask is off
            }
        }
    `,
    transparent: true
});

        // Plane to display the shader
        const geometry = new THREE.PlaneGeometry(width, height);
        const mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        // Update texture on drawing
        const updateTexture = () => {
            maskTexture.needsUpdate = true;
        };

        // Animation loop
        const animate = () => {
            material.uniforms.iTime.value += 0.01;
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        };

        animate();
    </script>
</body>
</html>

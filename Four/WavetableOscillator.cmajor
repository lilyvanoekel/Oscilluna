namespace Synth
{
    processor WavetableOscillator
    {
        input event float frequencyIn;
        input event float[] wavetableIn;
        input stream float gainIn;
        output stream float out;

        float phase = 0.0f;
        float phaseIncrement = 0.0f;
        float freq = 0.0f;
        float[] wavetable;
        int wavetableIndex = 0;

        event frequencyIn (float f)
        {
            freq = f;
            wavetableIndex = Util::frequency_to_wavetable_index(freq, WAVETABLE_BUCKETS_MIN_FREQUENCY, WAVETABLE_BUCKETS_MAX_FREQUENCY, WAVETABLE_NUM_BUCKETS);
        }

        event wavetableIn (float[] newTable)
        {
            wavetable = newTable;
        }

        void main()
        {
            float tableSizeFloat = float(TABLE_SIZE);
            
            loop
            {
                if (gainIn > 0.0001) {
                    let indexOffset = wavetableIndex * TABLE_SIZE;
                    phaseIncrement = freq * (tableSizeFloat / float(processor.frequency));
                    phase += phaseIncrement;
                    
                    // Wrap phase to stay within the bounds of the wavetable
                    phase -= floor(phase / tableSizeFloat) * tableSizeFloat;
                    
                    let index = wrap<TABLE_SIZE>(int32(phase));
                    let nextIndex = wrap<TABLE_SIZE>(index + 1);
                    let prevIndex = wrap<TABLE_SIZE>(index - 1);
                    let nextNextIndex = wrap<TABLE_SIZE>(index + 2);
                    
                    let frac = phase - float(index);
                    
                    // Fetch the four points needed for the interpolation
                    float value0 = wavetable[indexOffset + prevIndex];
                    float value1 = wavetable[indexOffset + index];
                    float value2 = wavetable[indexOffset + nextIndex];
                    float value3 = wavetable[indexOffset + nextNextIndex];
                    
                    // Perform Hermite interpolation
                    float slope0 = (value2 - value0) * 0.5f;
                    float slope1 = (value3 - value1) * 0.5f;
                    float v = value1 - value2;
                    float w = slope0 + v;
                    float a = w + v + slope1;
                    float b_neg = w + a;
                    float stage1 = a * frac - b_neg;
                    float stage2 = stage1 * frac + slope0;
                    float outputSample = stage2 * frac + value1;
                    out <- outputSample * gainIn;
                } else {
                    out <- 0.0f;
                }
                advance();
            }
        }
    }
}
namespace Common
{
    // Another moog style
    // @todo: figure out which to keep...
    processor ResonantLowpass {
        input stream float in;
        output stream float out;

        input event float cutoff;
        input event float resonance;

        float cutoff_;
        float resonance_;
        float srIntRecip;
        float alpha, K, qAdjust, pbg;
        float[4] z0, z1, beta;

        void init() {
            srIntRecip = 1.0f / float(processor.frequency);
            alpha = 1.0f;
            K = 1.0f;
            cutoff_ = 1000.0f;
            qAdjust = 1.0f;
            pbg = 0.5f;
            calc();
        }

        float fastTanh(float x) {
            if (x > 3.0f) return 1.0f;
            if (x < -3.0f) return -1.0f;
            float x2 = x * x;
            return x * (27.0f + x2) / (27.0f + 9.0f * x2);
        }

        event cutoff(float f) {
            // @todo figure out with testing and fix better
            // cutoff_ = min(f, float(processor.frequency) * 0.32f);
            cutoff_ = min(f, 14112.0f);
            calc();
        }

        event resonance(float f) {
            resonance_ = clamp(f, 0.0f, 1.8f);
            K = 4.0f * resonance_;
            calc();
        }

        void calc() {
            float freq = clamp(cutoff_, 5.0f, float(processor.frequency) * 0.425f);
            float wc = freq * 2.0f * 3.1415926535897931f * srIntRecip;
            float wc2 = wc * wc;
            alpha = 0.9892f * wc - 0.4324f * wc2 + 0.1381f * wc * wc2 - 0.0202f * wc2 * wc2;
            qAdjust = 1.006f + 0.0536f * wc - 0.095f * wc2 - 0.05f * wc2 * wc2;
        }

        float LPF(float s, wrap<4> i) {
            float ft = s * 0.76923077f + 0.23076923f * z0[i] - z1[i];
            ft = ft * alpha + z1[i];
            z1[i] = ft;
            z0[i] = s;
            return ft;
        }

        void main() {
            loop {
                float u = in - (z1[3] - pbg * in) * K * qAdjust;
                u = fastTanh(u);
                float stage1 = LPF(u, 0);
                float stage2 = LPF(stage1, 1);
                float stage3 = LPF(stage2, 2);
                float stage4 = LPF(stage3, 3);
                float outputSignal = stage4;
                out <- outputSignal;
                advance();
            }
        }
    }
}

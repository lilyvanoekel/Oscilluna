namespace Common
{
    namespace Filters {
        processor AllPassFilter {
            input stream float in;
            output stream float out;

            input stream float coefficientMod;
            input event float coefficientIn;
            input event float modDepthIn;

            float state = 0.0f;
            float coefficient = 0.5f;
            float modDepth = 0.2f;

            event coefficientIn(float coef) {
                coefficient = clamp(coef, 0.2f, 0.8f);
            }

            event modDepthIn(float f) {
                modDepth = f * 0.2f;
            }

            void main()
            {
                loop
                {
                    let moddedCoefficient = coefficient + coefficientMod * modDepth;
                    let result = -moddedCoefficient * in + state;
                    state = in + moddedCoefficient * result;
                    out <- result;
                    advance();
                }
            }
        }

        // Another moog style, source: DaisySP https://github.com/electro-smith/DaisySP
        // @todo: figure out which to keep...
        processor ResonantLowpass {
            input stream float in;
            output stream float out;
            input stream float freqModIn;

            input event float cutoff;
            input event float resonance;

            float cutoff_;
            float resonance_;
            float srIntRecip;
            float alpha, K, qAdjust, pbg;
            float[4] z0, z1, beta;

            void init() {
                srIntRecip = 1.0f / float(processor.frequency);
                alpha = 1.0f;
                K = 1.0f;
                cutoff_ = 1000.0f;
                qAdjust = 1.0f;
                pbg = 0.5f;
            }

            event cutoff(float f) {
                
                cutoff_ = min(f, 14112.0f);
            }

            event resonance(float f) {
                resonance_ = clamp(f, 0.0f, 1.8f);
                K = 4.0f * resonance_;
            }

            float LPF(float s, wrap<4> i) {
                float ft = s * 0.76923077f + 0.23076923f * z0[i] - z1[i];
                ft = ft * alpha + z1[i];
                z1[i] = ft;
                z0[i] = s;
                return ft;
            }

            void main() {
                loop {
                    // @todo figure out with testing and fix better
                    let freq = clamp(cutoff_ * (1.0f + freqModIn), 5.0f, 14112.0f);

                    let wc = freq * 2.0f * 3.1415926535897931f * srIntRecip;
                    let wc2 = wc * wc;
                    alpha = 0.9892f * wc - 0.4324f * wc2 + 0.1381f * wc * wc2 - 0.0202f * wc2 * wc2;
                    qAdjust = 1.006f + 0.0536f * wc - 0.095f * wc2 - 0.05f * wc2 * wc2;
                    
                    float u = in - (z1[3] - pbg * in) * K * qAdjust;
                    u = Util::fastTanh(u);
                    let stage1 = LPF(u, 0);
                    let stage2 = LPF(stage1, 1);
                    let stage3 = LPF(stage2, 2);
                    let stage4 = LPF(stage3, 3);
                    out <- stage4;
                    advance();
                }
            }
        }

        // @todo: needs work, or to be removed eventually
        // Source: https://www.musicdsp.org/en/latest/Filters/24-moog-vcf.html
        processor MoogFilter {
            input stream float in;
            output stream float out;

            input event float cutoff;
            input event float resonance;

            float cutoff_;
            float resonance_;
            float y1, y2, y3, y4;
            float oldx, oldy1, oldy2, oldy3;
            float x, p, k, r;

            event cutoff(float f)       { cutoff_ = f;      calc(); }
            event resonance(float f)    { resonance_ = f;   calc(); }

            void init() {
                y1 = 0.0f;
                y2 = 0.0f;
                y3 = 0.0f;
                y4 = 0.0f;
                oldx = 0.0f;
                oldy1 = 0.0f;
                oldy2 = 0.0f;
                oldy3 = 0.0f;
                calc();
            }

            void calc() {
                let kPi = 3.1415926535897931f;
                let f = 2.0f * cutoff_ / float(processor.frequency);
                k = 2.0f * sin(f * kPi * 0.5f) - 1.0f;
                p = (k + 1.0f) * 0.5f;
                float scale = exp((1.0f - p) * 1.386249f);
                r = resonance_ * scale;
            }

            void main() {
                loop {
                    x = in - r * y4;

                    y1 =  x * p + oldx  * p - k * y1;
                    y2 = y1 * p + oldy1 * p - k * y2;
                    y3 = y2 * p + oldy2 * p - k * y3;
                    y4 = y3 * p + oldy3 * p - k * y4;

                    y4 -= (y4 * y4 * y4) / 6.0f;

                    oldx = x; oldy1 = y1; oldy2 = y2; oldy3 = y3;

                    out <- y4;
                    advance();
                }
            }
        }
    }
}
namespace Common
{
    namespace Filters {
        // processor AllPassFilter {
        //     input stream float in;
        //     output stream float out;

        //     input event float feedbackIn;

        //     float feedback;

        //     event feedbackIn(float fb) {
        //         feedback = fb;
        //     }

        //     float state = 0.0f;

        //     void main()
        //     {
        //         loop
        //         {
        //             let result = state + feedback * (in - state);
        //             state = in - feedback * result;
        //             out <- result;
        //             advance();
        //         }
        //     }
        // }


        // Another moog style, source: DaisySP https://github.com/electro-smith/DaisySP
        // @todo: figure out which to keep...
        processor ResonantLowpass {
            input stream float in;
            output stream float out;

            input event float cutoff;
            input event float resonance;

            float cutoff_;
            float resonance_;
            float srIntRecip;
            float alpha, K, qAdjust, pbg;
            float[4] z0, z1, beta;

            void init() {
                srIntRecip = 1.0f / float(processor.frequency);
                alpha = 1.0f;
                K = 1.0f;
                cutoff_ = 1000.0f;
                qAdjust = 1.0f;
                pbg = 0.5f;
                calc();
            }

            event cutoff(float f) {
                // @todo figure out with testing and fix better
                // cutoff_ = min(f, float(processor.frequency) * 0.32f);
                cutoff_ = min(f, 14112.0f);
                calc();
            }

            event resonance(float f) {
                resonance_ = clamp(f, 0.0f, 1.8f);
                K = 4.0f * resonance_;
                calc();
            }

            void calc() {
                float freq = clamp(cutoff_, 5.0f, float(processor.frequency) * 0.425f);
                float wc = freq * 2.0f * 3.1415926535897931f * srIntRecip;
                float wc2 = wc * wc;
                alpha = 0.9892f * wc - 0.4324f * wc2 + 0.1381f * wc * wc2 - 0.0202f * wc2 * wc2;
                qAdjust = 1.006f + 0.0536f * wc - 0.095f * wc2 - 0.05f * wc2 * wc2;
            }

            float LPF(float s, wrap<4> i) {
                float ft = s * 0.76923077f + 0.23076923f * z0[i] - z1[i];
                ft = ft * alpha + z1[i];
                z1[i] = ft;
                z0[i] = s;
                return ft;
            }

            void main() {
                loop {
                    float u = in - (z1[3] - pbg * in) * K * qAdjust;
                    u = Util::fastTanh(u);
                    float stage1 = LPF(u, 0);
                    float stage2 = LPF(stage1, 1);
                    float stage3 = LPF(stage2, 2);
                    float stage4 = LPF(stage3, 3);
                    float outputSignal = stage4;
                    out <- outputSignal;
                    advance();
                }
            }
        }

        // @todo: needs work, or to be removed eventually
        // Source: https://www.musicdsp.org/en/latest/Filters/24-moog-vcf.html
        processor MoogFilter {
            input stream float in;
            output stream float out;

            input event float cutoff;
            input event float resonance;

            float cutoff_;
            float resonance_;
            float y1, y2, y3, y4;
            float oldx, oldy1, oldy2, oldy3;
            float x, p, k, r;

            event cutoff(float f)       { cutoff_ = f;      calc(); }
            event resonance(float f)    { resonance_ = f;   calc(); }

            void init() {
                y1 = 0.0f;
                y2 = 0.0f;
                y3 = 0.0f;
                y4 = 0.0f;
                oldx = 0.0f;
                oldy1 = 0.0f;
                oldy2 = 0.0f;
                oldy3 = 0.0f;
                calc();
            }

            void calc() {
                let kPi = 3.1415926535897931f;
                let f = 2.0f * cutoff_ / float(processor.frequency);
                k = 2.0f * sin(f * kPi * 0.5f) - 1.0f;
                p = (k + 1.0f) * 0.5f;
                float scale = exp((1.0f - p) * 1.386249f);
                r = resonance_ * scale;
            }

            void main() {
                loop {
                    x = in - r * y4;

                    y1 =  x * p + oldx  * p - k * y1;
                    y2 = y1 * p + oldy1 * p - k * y2;
                    y3 = y2 * p + oldy2 * p - k * y3;
                    y4 = y3 * p + oldy3 * p - k * y4;

                    y4 -= (y4 * y4 * y4) / 6.0f;

                    oldx = x; oldy1 = y1; oldy2 = y2; oldy3 = y3;

                    out <- y4;
                    advance();
                }
            }
        }
    }
}